#include <iostream> 
#include <fstream>
#include <string>
#include <vector>

#include <stdint.h>
#include <sys/stat.h> 
#include <sys/types.h> 
#include <time.h>

#include "tinyxml2.h"
#include "verilogfactory.h"

using namespace std;

// global configs
int cores;
string target;
string libfolder;
string lib;
string effort;

// multiplier configs
struct st_mul {
	string name;
	string reset;
	int width1;
	int width2;
	double freq;
	int digit_size = 1;
	int pipeline;
};

vector <st_mul> muls;

void readConfig();
void genLogs();
void genMultipliers();
void genScripts();
void readResults();
static inline uint32_t log2(const uint32_t x);

int main(int argc, char** argv) 
{ 
	readConfig();
	genLogs();
	genMultipliers();
	genScripts();
	readResults();
	return 0; 
}

void readConfig() {
	tinyxml2::XMLDocument doc;
	doc.LoadFile( "config.xml" );

	cout << "Starting the tool, reading config.xml" << endl; 

	// reads tool configuration related stuff
	tinyxml2::XMLElement *root, *child, *child1, *child2, *child3, *child4, *child5, *child6;
	root = doc.FirstChildElement( "CONFIG" );
	if (!root) {
		cout << "error reading XML CONFIG root" << endl;
		return;
	}

	child = root->FirstChildElement( "CORES" );
	cores = atoi(child->GetText());

	child = root->FirstChildElement( "TARGET" );
	target = child->GetText();
	child = root->FirstChildElement( "LIBFOLDER" );
	libfolder = child->GetText();
	child = root->FirstChildElement( "LIB" );
	lib = child->GetText();
	child = root->FirstChildElement( "EFFORT" );
	effort = child->GetText();

	// reads multiplier specific stuff
	root = doc.FirstChildElement( "MUL" );

	while (root) {
		string temp; // will store the name
		child= root->FirstChildElement( "NAME" ); // there can be only one
		if (!child) {
			cout << "ERROR: NAME tag missing for multiplier" << endl; // this is mandatory, abort if name is not found
			return;
		}
		temp = child->GetText();

		child1 = root->FirstChildElement( "RESET" ); 
		if (!child1) {
			cout << "ERROR: RESET tag missing for multiplier " << temp << endl;
			return;
		}

		child2 = root->FirstChildElement( "WIDTH1" );
		if (!child2) {
			cout << "ERROR: WIDTH1 tag missing for multiplier " << temp << endl;
			return;
		}

		child3 = root->FirstChildElement( "WIDTH2" );
		if (!child3) {
			cout << "ERROR: WIDTH2 tag missing for multiplier " << temp << endl;
			return;
		}

		child4 = root->FirstChildElement( "CLOCK" ); 
		if (!child4) {
			cout << "ERROR: CLOCK tag missing for multiplier " << temp << endl;
			return;
		}

  		child5 = root->FirstChildElement( "DIGIT_SIZE" ); // optional
		child6 = root->FirstChildElement( "PIPELINE" ); // optional
	
		cout << "mul: " << temp << " width1: " << child2->GetText() << " width2: " << child3->GetText() << " freq: " << child4->GetText() << " digit_size: " << child5->GetText() << " stages: " << child6->GetText() << endl;

		struct st_mul mul = {temp, child1->GetText(), atoi(child2->GetText()), atoi(child3->GetText()), stod(child4->GetText()), atoi(child5->GetText()), atoi(child6->GetText())};

		// here I must check for invalid configurations
		//if (mul.name == "schoolbook") {
		//	if (mul.reset == "none") {
		//		cout << "schoolbook multipler requires reset"
		//	}
		//} 	

		muls.push_back(mul);
		
		root = root->NextSiblingElement("MUL");
	}
}

void genLogs() {
	for (const auto& mul : muls) { // const because we don't operate on the elements, only read
		string filename = "../vlog/" + mul.name + "/" + mul.name + ".log";
		ofstream log (filename.c_str());

		string dirname = "../vlog/" + mul.name;
		mkdir(dirname.c_str(), 0777);
		dirname = "../synth/" + mul.name;
		mkdir(dirname.c_str(), 0777);

		time_t     now = time(0);
		struct tm  tstruct;
		char       buf[80];
		tstruct = *localtime(&now);
		strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct);

		if (log.is_open()) {
			log << "This is generated by TTech-LIB on " << buf << endl;
			log.close();
		}
	}
}

void genMultipliers() {
	for (const auto& mul : muls) { // const because we don't operate on the elements, only read
		string filename = "";
		if (mul.name == "sbm_digitized"){
			filename = "../vlog/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + "." + "dig" + to_string(mul.digit_size) +".pip" + to_string(mul.pipeline) +".v";
		}
		else{
			filename = "../vlog/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + ".pip" + to_string(mul.pipeline) +".v";
		}
		ofstream vlog (filename.c_str());

		cout << filename << endl;

		if (!vlog.is_open()) {
			cout << "problem opening file " << filename << endl;
			return;
		}

		vlog << "// TalTech large integer multiplier library" << endl;
		vlog << "// Multiplier type: " << mul.name << endl;
		vlog << "// Parameters: " << mul.width1 << " " << mul.width2 << " " << mul.pipeline << endl;
		vlog << "// Target tool: " << target << endl;

		VerilogFactory fact;
		fact.setName(mul.name);

		if (mul.name == "simple") {
			fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", mul.width1 + mul.width2);

			fact.genTempVars(mul.pipeline, true);

			vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;

			if (mul.reset != "none") {
				if (mul.reset == "posedge") {
					vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET1]) << endl;
				}
				if (mul.reset == "negedge") {
					vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET0]) << endl;
				}
				vlog << VerilogFactory::scoper(2, fact.getResetStatement(true)) << endl;
				vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
				vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::ELSEBEGIN]) << endl;
				vlog << VerilogFactory::scoper(2, fact.getMulLogicSimple(mul.pipeline)) << endl;
				vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			}
			else {
				vlog << VerilogFactory::scoper(1, fact.getMulLogicSimple(mul.pipeline)) << endl;		
			}	

			vlog << fact.snippet[VerilogFactory::END] << endl;
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}

		if (mul.name == "schoolbook") {
			fact.addIO("clk", "input"); // special inputs
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1); // regular inputs
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", mul.width1 + mul.width2);
			fact.addVar("count", log2(mul.width1) + 1, false); // TODO: check this is really width1
			if (mul.pipeline > 1) {
				fact.addVar("skip", log2(mul.pipeline - 1) + 1, false);
			}

			fact.genTempVars(mul.pipeline, true);

			vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined regs are declared here
			vlog << fact.getInternalDefinition() << endl; // internal variables are declared here
			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;

			if (mul.reset == "posedge") {
				vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET1]) << endl;
			}
			else { // the none case will fall here, which is ok
				vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET0]) << endl;
			}
			
			if (mul.reset == "none") { // note there will always be a reset for schoolbook because the counters have to be managed. so here the user only decides the behavior of the reset for the pipeline registers
				vlog << VerilogFactory::scoper(2, fact.getResetStatement(false)) << endl;
			}
			else {
				vlog << VerilogFactory::scoper(2, fact.getResetStatement(true)) << endl;
			}
			
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::ELSEBEGIN]) << endl;
			vlog << VerilogFactory::scoper(2, fact.getMulLogicSchoolbook(mul.width1, mul.width2, mul.pipeline)) << endl;
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}

		if (mul.name == "booth") {
   			fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", mul.width1 + mul.width2);
			      
      		// To declare reg in the generated verilog file
      		fact.addVar("mul_w_signguard", mul.width1, false); // declare reg equal to the size of an operand
      		fact.addVar("count", log2(mul.width1) + 1, false); // TODO: check this is really count log2(operand)
      		fact.addVar("add_w_signguard", mul.width1, false); // declare reg equal to the size of an operand
      		fact.addVar("mul_ab1", (mul.width1 + mul.width2) , false); // register to store multiplication result of a1 and c1 and its width will be sum of widths of a1 and c1

      
			vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			vlog << "// Pipeine registers" << endl;
			vlog << fact.BoothPipeline(mul.pipeline, mul.width1) << endl; // pipelined inputs are declared here
			vlog << fact.getInternalDefinitionWire() << endl;
			vlog << "// Registers declaration " << endl;
			vlog << fact.getInternalDefinition() << endl; 
						      
			// Step_1
			vlog << "// Step-1 of Booth Multiplier" << endl;
			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			vlog << VerilogFactory::scoper(1, fact.getMulLogic_Booth_Step_1(mul.width1, mul.width2, log2(mul.width1) + 1, mul.pipeline)) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
      
			// Step_2
      		vlog << endl << "// Step-2 of Booth Multiplier" << endl;
      		vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      		vlog << VerilogFactory::scoper(1, fact.getMulLogic_Booth_Step_2(mul.width1, mul.width2, mul.pipeline)) << endl;
      		vlog << fact.snippet[VerilogFactory::END] << endl;
				
			// Step_3
      		vlog << endl << "// Step-3 of Booth Multiplier" << endl;
      		vlog << fact.snippet[VerilogFactory::ALWAYS_ASTERIK] << endl;
      		vlog << VerilogFactory::scoper(1, fact.getMulLogic_Booth_Step_3(mul.width1, mul.width2, mul.pipeline)) << endl;
      		vlog << fact.snippet[VerilogFactory::END] << endl;

      		// Step_4
      		vlog << endl << "// Step-4 of Booth Multiplier" << endl;
      		vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      		vlog << VerilogFactory::scoper(1, fact.getMulLogic_Booth_Step_4(mul.width1, mul.width2, mul.pipeline)) << endl;
      		vlog << fact.snippet[VerilogFactory::END] << endl;
				
			// Step_5
      		vlog << endl << "// Step-5 of Booth Multiplier" << endl;
      		vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			vlog << VerilogFactory::scoper(1, fact.getMulLogic_Booth_Step_5(mul.width1, mul.width2, mul.pipeline)) << endl;
      		vlog << fact.snippet[VerilogFactory::END] << endl;
				
      		if (mul.pipeline > 1) {
	      		vlog << endl << "// pipeline stages" << endl;
      			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;

				int i = mul.pipeline;
				std::string temp;

				temp = "add_w_signguard <= c_temp_1;\n";
      				vlog << VerilogFactory::scoper(1, temp) << endl;

				while (i > 2) {
					temp = "c_temp_" + std::to_string(i-2) + " <= c_temp_" + std::to_string(i-1) + ";\n";
	      				vlog << VerilogFactory::scoper(1, temp) << endl;
      					i--;
				}

					vlog << fact.snippet[VerilogFactory::END] << endl;
			}
			
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}
			if (mul.name == "two_way_karatsuba") {
   			fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", mul.width1 + mul.width2);

			fact.genTempVars(mul.pipeline, false);
			
			// To declare wires in the generated verilog file
			fact.addWire("a1", mul.width1/2); // include wire
			fact.addWire("b1", mul.width1/2); // include wire
			fact.addWire("c1", mul.width1/2); // include wire
			fact.addWire("d1", mul.width1/2); // include wire
      			fact.addWire("sum_a1b1", (mul.width1/2)+1); // include wire
      			fact.addWire("sum_c1d1", (mul.width1/2)+1); // include wire
      			      
      			// To declare reg in the generated verilog file
      			fact.addVar("counter_a1c1", mul.width1/2, false); // will check 2 bits of a1
      			fact.addVar("counter_b1d1", mul.width1/2, false); // will check 2 bits of b1
      			fact.addVar("counter_sum_a1b1_c1d1", (mul.width1/2)+2, false); //will check 3 bits
      			fact.addVar("mul_a1c1", mul.width1, false); // register to store multiplication result of a1 and c1 and its width will be sum of widths of a1 and c1
      			fact.addVar("mul_b1d1", mul.width1, false); 
      			fact.addVar("mul_sum_a1b1_sum_c1d1", mul.width1 + 2, false); 
      
			vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			vlog << "// Pipeline register declaration " << endl;
			vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
			vlog << "// Wires declaration " << endl;
			vlog << fact.getInternalDefinitionWire() << endl;
			vlog << "// Registers declaration " << endl;
			vlog << fact.getInternalDefinition() << endl; // pipelined inputs are declared here
			
			// Initial assignments
			vlog << "// breaking the inputs into 4 parts of equal length" << endl;
			vlog << "assign a1 = a[" << std::to_string(mul.width1 -1) << ":" <<  std::to_string(mul.width1/2) << "];" << endl;
			vlog << "assign b1 = a[" << std::to_string(mul.width1/2 -1) << ":" <<  std::to_string(0) << "];" << endl;
			vlog << "assign c1 = b[" << std::to_string(mul.width2 -1) << ":" <<  std::to_string(mul.width2/2) << "];" << endl;
			vlog << "assign d1 = b[" << std::to_string(mul.width2/2 -1) << ":" <<  std::to_string(0) << "];" << endl;
						      
			// Step_1
			vlog << "// Step-1 of 2-Way Karatsuba Multiplier" << endl;
			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			vlog << VerilogFactory::scoper(1, fact.getMulLogic_2_Way_Karatsuba_Step_1(mul.width1, mul.width2, mul.pipeline)) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
      
			// Step_2
      			vlog << endl << "// Step-2 of 2-Way Karatsuba Multiplier" << endl;
      			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      			vlog << VerilogFactory::scoper(1, fact.getMulLogic_2_Way_Karatsuba_Step_2(mul.width1, mul.width2, mul.pipeline)) << endl;
      			vlog << fact.snippet[VerilogFactory::END] << endl;
      			
      			vlog << endl << "// Assignments to sum_a1b1 and sum_c1d1" << endl;
      			vlog << "assign sum_a1b1 = a1 ^ b1;" << endl;
      			vlog << "assign sum_c1d1 = c1 ^ d1;" << endl;

      			// Step_3
      			vlog << endl << "// Step-3 of 2-Way Karatsuba Multiplier" << endl;
      			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      			vlog << VerilogFactory::scoper(1, fact.getMulLogic_2_Way_Karatsuba_Step_3(mul.width1, mul.width2, mul.pipeline)) << endl;
      			vlog << fact.snippet[VerilogFactory::END] << endl;

      			if (mul.pipeline > 1) {
	      			vlog << endl << "// pipeline stages" << endl;
      				vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;

				int i = mul.pipeline;
				std::string temp;

				temp = "c <= c_temp_1;\n";
      				vlog << VerilogFactory::scoper(1, temp) << endl;

				while (i > 2) {
					temp = "c_temp_" + std::to_string(i-2) + " <= c_temp_" + std::to_string(i-1) + ";\n";
	      				vlog << VerilogFactory::scoper(1, temp) << endl;
      					i--;
				}

					vlog << fact.snippet[VerilogFactory::END] << endl;
			}
			
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}
	if (mul.name == "three_way_toom_cook") {
      
   		fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", (mul.width1 + mul.width2));
			
		fact.genTempVars(mul.pipeline, false);
	  int width_a = mul.width1 - 1;
	  int width_b = mul.width2 - 1;
      // To split the input operands into three equal sizes
      //vlog << "// Here, we split the input operands into three equal sizes"  + std::to_string(mul.width1) << endl;
      fact.addWire("a0", ((width_a/3) - 0) + 1); // include wire
      fact.addWire("a1", (((width_a*2)/3) - ((width_a/3) + 1)) + 1); // include wire
      fact.addWire("a2", (width_a - (((width_a*2)/3) + 1)) + 1); // include wire
      fact.addWire("b0", ((width_b/3) - 0) + 1); // include wire
      fact.addWire("b1", (((width_b*2)/3) - ((width_b/3) + 1)) + 1); // include wire
      fact.addWire("b2", (width_b - (((width_b*2)/3) + 1)) + 1); // include wire
            
      // Counters for each step of 3-Way TCM multiplier
      vlog << "// Counters deceleration for each step of 3-Way TCM multiplier" << endl;
      fact.addVar("counter_d", (mul.width1/3), false); // will check bits of d
      fact.addVar("counter_e1", (mul.width1/3), false); // will check bits of e1
      fact.addVar("counter_e2", (mul.width1/3), false); // will check bits of e2
      fact.addVar("counter_f1", (mul.width1/3), false); // will check bits of f1
      fact.addVar("counter_f2", (mul.width1/3), false); // will check bits of f2
      fact.addVar("counter_f3", (mul.width1/3), false); // will check bits of f3
      fact.addVar("counter_g1", (mul.width1/3), false); // will check bits of g1
      fact.addVar("counter_g2", (mul.width1/3), false); // will check bits of g2
      fact.addVar("counter_h", (mul.width1/3), false); // will check bits of h
      
      // To store intermediate multiplication results
      vlog << "// To store intermediate multiplication results of 3-Way TCM multiplier" << endl;
      fact.addVar("d", mul.width1, false); 
      fact.addVar("e1_mul", mul.width1, false);
      fact.addVar("e2_mul", mul.width1, false);
      fact.addVar("e", mul.width1, false); // e = e1_mul + e2_mul
      fact.addVar("f1_mul", mul.width1, false);
      fact.addVar("f2_mul", mul.width1, false);
      fact.addVar("f3_mul", mul.width1, false);
      fact.addVar("f", mul.width1, false); // f = f1_mul + f2_mul + f3_mul
      fact.addVar("g1_mul", mul.width1, false);
      fact.addVar("g2_mul", mul.width1, false);
      fact.addVar("g", mul.width1, false); // g = g1_mul + g2_mul
      fact.addVar("h", mul.width1, false);
      fact.addVar("temp", (mul.width1 + mul.width2), false);
      
      vlog << fact.getModuleDefinition() << endl;
	  vlog << fact.getIODefinition() << endl;
	  vlog << "// Pipeline register declaration " << endl;
	  vlog << fact.TCMPipeline(mul.pipeline, 3) << endl; // pipelined inputs are declared here
      vlog << "// Wires declaration " << endl;
      vlog << fact.getInternalDefinitionWire() << endl;
      vlog << "// Registers declaration " << endl;
			vlog << fact.getInternalDefinition() << endl; // pipelined inputs are declared here
      
      // Initial assignments to wires
      vlog << "// Initial assignments to wires" << endl;
      vlog << "assign a0 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_3_minus_1("a") << ":0];" << endl;
      vlog << "assign a1 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_2_over_3_minus_1("a") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_3("a") << "];" << endl;
      vlog << "assign a2 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1_for_3_way_TCM("a") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_2_over_3("a") << "];" << endl;
      vlog << "assign b0 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_3_minus_1("b") << ":0];" << endl;
      vlog << "assign b1 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_2_over_3_minus_1("b") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_3("b") << "];" << endl;
      vlog << "assign b2 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1_for_3_way_TCM("b") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_2_over_3("b") << "];" << endl;
      
      
      // Step_1
      vlog << endl << "// Step-1 of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
	  vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_1(mul.width1, mul.width2, mul.pipeline)) << endl;	
	  vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-1)
      vlog << endl << "// Step-2 (Part-1) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_2_part_1(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-2)
      vlog << endl << "// Step-2 (Part-2) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_2_part_2(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-3)
      vlog << endl << "// Step-2 (Part-3) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_2_part_3(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
            
      // Step_3 (Part-1)
      vlog << endl << "// Step-3 (Part-1) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_3_part_1(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-2)
      vlog << endl << "// Step-3 (Part-2) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_3_part_2(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-3)
      vlog << endl << "// Step-3 (Part-3) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_3_part_3(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-4)
      vlog << endl << "// Step-3 (Part-4) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_3_part_4(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_4 (Part-1)
      vlog << endl << "// Step-4 (Part-1) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_4_part_1(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-2)
      vlog << endl << "// Step-4 (Part-2) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_4_part_2(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-3)
      vlog << endl << "// Step-4 (Part-3) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_4_part_3(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_5
      vlog << endl << "// Step-5 of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_5(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_6
      vlog << endl << "// Step-6 of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << VerilogFactory::scoper(1, fact.getMulLogic_3_Way_TCM_Step_6(mul.width1, mul.width2, mul.pipeline)) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;

      if (mul.pipeline > 1) {
	      			vlog << endl << "// pipeline stages" << endl;
      				vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;

				int i = mul.pipeline;
				std::string temp;

				temp = "c_temp_"+ std::to_string(i-(i-1)) + " <= f;\n";
      				vlog << VerilogFactory::scoper(1, temp) << endl;

				while (i > 2) {
					temp = "c_temp_" + std::to_string(i-1) + " <= c_temp_" + std::to_string(i-2) + ";\n";
	      				vlog << VerilogFactory::scoper(1, temp) << endl;
      					i--;
				}

					vlog << fact.snippet[VerilogFactory::END] << endl;
			}
			
	  vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}

if (mul.name == "four_way_toom_cook") {
      
   		fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", (mul.width1 + mul.width2));
		fact.genTempVars(mul.pipeline, false);
	  int width_a = mul.width1 - 1;
	  int width_b = mul.width2 - 1;
	  
      // To split the input operands into three equal sizes
      //vlog << "// Here, we split the input operands into three equal sizes" << endl;
      //fact.addWire("a0", (mul.width1/4)); // include wire
      //fact.addWire("a1", (mul.width1/4)); // include wire
      //fact.addWire("a2", (mul.width1/4)); // include wire
      //fact.addWire("a3", (mul.width1/4)); // include wire
      //fact.addWire("b0", (mul.width1/4)); // include wire
      //fact.addWire("b1", (mul.width1/4)); // include wire
      //fact.addWire("b2", (mul.width1/4)); // include wire
      //fact.addWire("b3", (mul.width1/4)); // include wire
      
	  fact.addWire("a0", ((width_a/4) - 0) + 1); // include wire
      fact.addWire("a1", (((width_a*2)/4) - ((width_a/4) + 1)) + 1); // include wire
      fact.addWire("a2", (((width_a*3)/4) - (((width_a*2)/4) + 1)) + 1); // include wire
	  fact.addWire("a3", (width_a - (((width_a*3)/4) + 1)) + 1); // include wire
	  
	  fact.addWire("b0", ((width_b/4) - 0) + 1); // include wire
      fact.addWire("b1", (((width_b*2)/4) - ((width_b/4) + 1)) + 1); // include wire
      fact.addWire("b2", (((width_b*3)/4) - (((width_b*2)/4) + 1)) + 1); // include wire
	  fact.addWire("b3", (width_b - (((width_b*3)/4) + 1)) + 1); // include wire
	  
      // Counters for each step of 3-Way TCM multiplier
      //vlog << "// Counters deceleration for each step of 3-Way TCM multiplier" << endl;
      fact.addVar("counter_d", (mul.width1/4), false); // will check bits of d
      fact.addVar("counter_e1", (mul.width1/4), false); // will check bits of e1
      fact.addVar("counter_e2", (mul.width1/4), false); // will check bits of e2
      fact.addVar("counter_f1", (mul.width1/4), false); // will check bits of f1
      fact.addVar("counter_f2", (mul.width1/4), false); // will check bits of f2
      fact.addVar("counter_f3", (mul.width1/4), false); // will check bits of f3
      fact.addVar("counter_g1", (mul.width1/4), false); // will check bits of g1
      fact.addVar("counter_g2", (mul.width1/4), false); // will check bits of g2
      fact.addVar("counter_g3", (mul.width1/4), false); // will check bits of g3
      fact.addVar("counter_g4", (mul.width1/4), false); // will check bits of g4
      fact.addVar("counter_h1", (mul.width1/4), false); // will check bits of h1
      fact.addVar("counter_h2", (mul.width1/4), false); // will check bits of h2
      fact.addVar("counter_h3", (mul.width1/4), false); // will check bits of h3
      fact.addVar("counter_i1", (mul.width1/4), false); // will check bits of i1
      fact.addVar("counter_i2", (mul.width1/4), false); // will check bits of i2
      fact.addVar("counter_j", (mul.width1/4), false); // will check bits of j
      
      // To store intermediate multiplication results
      //vlog << "// To store intermediate multiplication results of 3-Way TCM multiplier" << endl;
      fact.addVar("d", mul.width1, false); 
      fact.addVar("e1_mul", mul.width1, false);
      fact.addVar("e2_mul", mul.width1, false);
      fact.addVar("e", mul.width1, false); // e = e1_mul + e2_mul
      fact.addVar("f1_mul", mul.width1, false);
      fact.addVar("f2_mul", mul.width1, false);
      fact.addVar("f3_mul", mul.width1, false);
      fact.addVar("f", mul.width1, false); // f = f1_mul + f2_mul + f3_mul
      fact.addVar("g1_mul", mul.width1, false);
      fact.addVar("g2_mul", mul.width1, false);
      fact.addVar("g3_mul", mul.width1, false);
      fact.addVar("g4_mul", mul.width1, false);
      fact.addVar("g", mul.width1, false); // g = g1_mul + g2_mul + g3_mul + g4_mul
      fact.addVar("h1_mul", mul.width1, false);
      fact.addVar("h2_mul", mul.width1, false);
      fact.addVar("h3_mul", mul.width1, false);
      fact.addVar("h", mul.width1, false); // h = h1_mul + h2_mul + h3_mul
      fact.addVar("i1_mul", mul.width1, false);
      fact.addVar("i2_mul", mul.width1, false);
      fact.addVar("i", mul.width1, false); // i = i1_mul + i2_mul
      fact.addVar("j", mul.width1, false);
      fact.addVar("temp", (mul.width1 + mul.width2), false);
      
      //vlog << "assign a0 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_2() << "];" << endl;
    
      //fact.getAssignonWire(); // first parameter towards left is the destination while another parameter towards right is the source to be copied 
             
      
			//if (mul.pipeline > 1) {
				//fact.addVar("skip", log2(mul.pipeline - 1) + 1);
			//}
      
      
      vlog << fact.getModuleDefinition() << endl;
	  vlog << fact.getIODefinition() << endl;
			//vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
	  vlog << "// Pipeline register declaration " << endl;
	  vlog << fact.TCMPipeline(mul.pipeline, 4) << endl; // pipelined inputs are declared here
      vlog << "// Wires declaration " << endl;
      vlog << fact.getInternalDefinitionWire() << endl;
      vlog << "// Registers declaration " << endl;
			vlog << fact.getInternalDefinition() << endl; // pipelined inputs are declared here
      
      // Initial assignments to wires
      vlog << "// Initial assignments to wires" << endl;
      vlog << "assign a0 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_4("a") << ":0];" << endl;
      vlog << "assign a1 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_2_over_4("a") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_4("a") << "];" << endl;
      vlog << "assign a2 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_3_over_4("a") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_2_over_4("a") << "];" << endl;
      vlog << "assign a3 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1_for_4_way_TCM("a") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_3_over_4("a") << "];" << endl;
      
      vlog << "assign b0 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_4("b") << ":0];" << endl;
      vlog << "assign b1 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_2_over_4("b") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_4("b") << "];" << endl;
      vlog << "assign b2 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_3_over_4("b") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_2_over_4("b") << "];" << endl;
      vlog << "assign b3 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1_for_4_way_TCM("b") << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_3_over_4("b") << "];" << endl;
      
      
      // Step_1
      vlog << endl << "// Step-1 of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET1]) << endl;
			//vlog << fact.getResetStatement();
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::ELSEBEGIN]) << endl;
			vlog << fact.getMulLogic_4_Way_TCM_Step_1(mul.width1, mul.width2, mul.pipeline); 		
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-1)
      vlog << endl << "// Step-2 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_2_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-2)
      vlog << endl << "// Step-2 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_2_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-3)
      vlog << endl << "// Step-2 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_2_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
            
      // Step_3 (Part-1)
      vlog << endl << "// Step-3 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_3_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-2)
      vlog << endl << "// Step-3 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_3_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-3)
      vlog << endl << "// Step-3 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_3_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-4)
      vlog << endl << "// Step-3 (Part-4) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_3_part_4(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_4 (Part-1)
      vlog << endl << "// Step-4 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-2)
      vlog << endl << "// Step-4 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-3)
      vlog << endl << "// Step-4 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl; 
      
      // Step_4 (Part-4)
      vlog << endl << "// Step-4 (Part-4) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_4(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-5)
      vlog << endl << "// Step-4 (Part-5) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_5(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;     
      
      // Step_5 (Part-1)
      vlog << endl << "// Step-5 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_5_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_5 (Part-2)
      vlog << endl << "// Step-5 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_5_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_5 (Part-3)
      vlog << endl << "// Step-5 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_5_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_5 (Part-4)
      vlog << endl << "// Step-5 (Part-4) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_5_part_4(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_6 (Part-1)
      vlog << endl << "// Step-6 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_6_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_6 (Part-2)
      vlog << endl << "// Step-6 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_6_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_6 (Part-3)
      vlog << endl << "// Step-6 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_6_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_7
      vlog << endl << "// Step-7 of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_7(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_8
      vlog << endl << "// Step-8 of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_8(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
		
		      if (mul.pipeline > 1) {
	      			vlog << endl << "// pipeline stages" << endl;
      				vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;

				int i = mul.pipeline;
				std::string temp;

				temp = "c_temp_"+ std::to_string(i-(i-1)) + " <= g;\n";
      				vlog << VerilogFactory::scoper(1, temp) << endl;

				while (i > 2) {
					temp = "c_temp_" + std::to_string(i-1) + " <= c_temp_" + std::to_string(i-2) + ";\n";
	      				vlog << VerilogFactory::scoper(1, temp) << endl;
      					i--;
				}

					vlog << fact.snippet[VerilogFactory::END] << endl;
			}
			
	  vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		
		}
   
   if (mul.name == "sbm_digitized") {
      
      fact.addParameter("SIZEA", mul.width1);
      fact.addParameter("SIZEB", mul.width2);
      fact.addParameter("SIZEOF_DIGITS", mul.digit_size);
      fact.addParameter("DIGITS", (mul.width2/mul.digit_size)+1);
      
      fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", (mul.width1 + mul.width2));
      
      fact.addVar("local_rst", 1, false);
      fact.addVar("digit_mul_start", 1, false);
      fact.addVar("digit_mul_start_next", 1, false);
      fact.addVar("short_b", mul.digit_size, false);
      fact.addVar("short_b_next", mul.digit_size, false);
      fact.addVar("counter_digits", mul.width2/mul.digit_size, false);
      fact.addVar("counter_digits_next", mul.width2/mul.digit_size, false);
      fact.addVar("state", 2, false); 
      fact.addVar("next_state", 2, false);
      fact.addVar("next_c", (mul.width1+mul.width2), false);
      fact.addVar("tmp", mul.width2, false);
      fact.addVar("upper_addr", (mul.width2/2)-1, false);
      fact.addVar("lower_addr", (mul.width2/2)-1, false);
      
      fact.addWire("digit_mul_done", 1);
      fact.addWire("short_c", (mul.width1 + mul.digit_size));
      
			//if (mul.pipeline > 1) {
				//fact.addVar("skip", log2(mul.pipeline - 1) + 1);
			//}
      
      vlog << fact.getModuleDefinition() << endl;      
      vlog << endl << "// Declaration of parameters" << endl;
      vlog << fact.getInternalDefinitionParameter() << endl;
      vlog << "// Declaration of module inputs and outputs" << endl;
			vlog << fact.getIODefinition() << endl;
      vlog << "// Set local parameters for FSM controller" << endl;
      vlog << "localparam ST_RUN = 0;" << endl;
      vlog << "localparam ST_WAIT = 1;" << endl;
      vlog << "localparam ST_OFFSET = 2;" << endl;
      vlog << "localparam ST_RST = 3;" << endl;
      vlog << endl << "// Registers declaration " << endl;
			vlog << fact.getInternalDefinition() << endl; 
			//vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
      vlog << "// Wires declaration " << endl;
      vlog << fact.getInternalDefinitionWire() << endl;
      
      vlog << "// Multiplier Instance" << endl;
      vlog << "mult_unit #(" << mul.width2 << ", " << mul.digit_size << ") mult_unit (clk, rst, local_rst, a, short_b, digit_mul_start, short_c, digit_mul_done);" << endl;
      
      // FSM Controller -- Sequential Block
      vlog << endl << "// FSM-controller --< Sequential Part" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_sbm_digitized_FSM_sequential_logic(mul.width1, mul.width2, mul.digit_size, mul.pipeline);
			vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // FSM Controller -- Combinational Block
      vlog << endl << "// FSM-controller --< Combinational Part" << endl;
      vlog << fact.getMulLogic_sbm_digitized_FSM_combinational_logic(mul.width1, mul.width2, mul.digit_size, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
      
      // multiplier inside the sbm_digitized
      vlog << endl << "// multiplier inside the sbm_digitized" << endl;
      vlog << "module mult_unit(clk, rst, local_rst, a, b, digit_mul_start, c, digit_mul_done);" << endl;
      
      vlog << endl << "// Declaration of parameters" << endl;
      vlog << "parameter SHORTA = 1;" << endl;
      vlog << "parameter SHORTB = 1;" << endl;
      
      vlog << endl << "// Declaration of module inputs and outputs" << endl;
      vlog << "input clk;" << endl;
			vlog << "input rst;" << endl;
      vlog << "input local_rst;" << endl;
      vlog << "input [" << (mul.width1-1) <<":0] a;" << endl;
      vlog << "input [" << (mul.digit_size-1) <<":0] b;" << endl;
      vlog << "input digit_mul_start;" << endl;
      vlog << "output reg [" << ((mul.width1 + mul.digit_size)-1) << ":0] c;" << endl;
      vlog << "output reg digit_mul_done;" << endl;
      
      vlog << endl << "// Registers declaration " << endl;
      vlog << "reg [11:0] count;" << endl;
 
      vlog << endl << fact.getMulLogic_multiplier_inside_sbm_digitized(mul.width1, mul.width2, mul.digit_size, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}
		vlog.close();
	}
}

void genScripts() {
	for (const auto& mul : muls) { 
		string filename = "";
		if (mul.name == "sbm_digitized"){
			filename = "../synth/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + "." + "dig" + to_string(mul.digit_size) + ".pip" + to_string(mul.pipeline) + ".tcl";
		}
		else{
			filename = "../synth/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + ".pip" + to_string(mul.pipeline) + ".tcl";
		}
		ofstream tcl (filename.c_str());

		if (!tcl.is_open()) {
			cout << "problem opening file " << filename << endl;
			return;
		}
	
		if (target == "genus") {
			tcl << "#created by TMlib" << endl;
			tcl << "set_db information_level 99" << endl;
			tcl << "set_db syn_global_effort " << effort << endl;
			tcl << "set_db syn_generic_effort " << effort << endl;
			tcl << "set_db syn_map_effort " << effort << endl;
			tcl << "set_db syn_opt_effort " << effort << endl;
			tcl << "set_db retime_verification_flow false" << endl;

			tcl << "set LIB {" << lib << "}" << endl;
			tcl << "set SOURCE_PATH {../../vlog/" << mul.name << "/}" << endl;
			if (mul.name == "sbm_digitized"){
				tcl << "set FILE_LIST {" << mul.name << "." << mul.width1 << "x" << mul.width2 << ".dig" << mul.digit_size << ".pip" << mul.pipeline << ".v}" << endl;
			}
			else{
				tcl << "set FILE_LIST {" << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".v}" << endl;
			}
			tcl << "set_db init_hdl_search_path \"$SOURCE_PATH\"" << endl;
			tcl << "set TOP MUL" << endl;

			tcl << "read_libs ${LIB}" << endl;
			tcl << "read_hdl \"$FILE_LIST\"" << endl;
			tcl << "time_info" << endl;
			tcl << "elaborate" << endl;
			if (mul.name == "sbm_digitized"){
				tcl << "write_hdl -generic > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".dig" << mul.digit_size << ".pip" << mul.pipeline << ".generic.v" << endl;
			}
			else{
				tcl << "write_hdl -generic > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".generic.v" << endl;
			}
			tcl << "time_info" << endl;
			tcl << "check_design -unresolved" << endl;
			tcl << "set_time_unit -nanoseconds" << endl;
			tcl << "set CLK_PORT_NAME clk" << endl;
			tcl << "create_clock -name \"fast\" -period " << mul.freq << " $CLK_PORT_NAME" << endl;
			//tcl << "#double check this input delay line" << endl;
			tcl << "set_input_delay -clock fast 0.001 [all_inputs]" << endl;

			tcl << "set_dont_use SDF*" << endl;
			tcl << "set_dont_use SED*" << endl;
			tcl << "set_dont_use DEL*" << endl;
			tcl << "set_dont_use CK*" << endl;
			tcl << "set_dont_use LH*" << endl;
			tcl << "set_dont_use LN*" << endl;
			tcl << "set_dont_use *DCAP*" << endl;

			if (mul.pipeline > 1) {
				tcl << "retime -prepare" << endl;
				tcl << "time_info" << endl;
				tcl << "retime -min_delay" << endl;
				tcl << "time_info" << endl;
			}

			tcl << "syn_generic" << endl;
			tcl << "time_info" << endl;
			tcl << "syn_map" << endl;
			tcl << "time_info" << endl;
			tcl << "syn_opt" << endl;
			tcl << "time_info" << endl;
			if (mul.name == "sbm_digitized"){
			tcl << "write_hdl > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".dig" << mul.digit_size << ".pip" << mul.pipeline << ".mapped.v" << endl;
			tcl << "report_area > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".dig" << mul.digit_size << ".pip" << mul.pipeline << ".area.rpt" << endl;
			tcl << "report_power > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".dig" << mul.digit_size << ".pip" << mul.pipeline << ".power.rpt" << endl;
			tcl << "report_timing > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".dig" << mul.digit_size << ".pip" << mul.pipeline << ".timing.rpt" << endl;
			tcl << "report_gates > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".dig" << mul.digit_size << ".pip" << mul.pipeline << ".gates.rpt" << endl;
			tcl << "report_runtime > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".dig" << mul.digit_size << ".pip" << mul.pipeline << ".runtime.rpt" << endl;
			}
			else{
			tcl << "write_hdl > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".mapped.v" << endl;
			tcl << "report_area > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".area.rpt" << endl;
			tcl << "report_power > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".power.rpt" << endl;
			tcl << "report_timing > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".timing.rpt" << endl;
			tcl << "report_gates > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".gates.rpt" << endl;
			tcl << "report_runtime > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".runtime.rpt" << endl;
			}
		}
		else if (target == "dc") {
			tcl << "#created by TMlib" << endl;
			tcl << "set search_path [list . \\" << endl;
			tcl << "[format \"%s%s\" SynopsysInstall /libraries/syn] \\" << endl;
			tcl << "[format \"%s%s\" SynopsysInstall /dw/sim_ver] \\" << endl;
			tcl << libfolder << " \\" << endl;
			tcl << "../../vlog/" << mul.name << "/]" << endl << endl;
	
			tcl << "set_host_options -max_cores " << cores << endl << endl;

			tcl << "set target_library [list " << lib << "]" << endl;
			tcl << "set link_library [concat [concat \"*\" $target_library] $synthetic_library]" << endl;
			tcl << "set fileFormat verilog" << endl;
			tcl << "set my_files [list " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".v]" << endl << endl;

			tcl << "analyze -format $fileFormat -lib WORK $my_files" << endl;
			tcl << "elaborate " << mul.name << endl;
			tcl << "link" << endl;
			tcl << "uniquify" << endl << endl;

			tcl << "create_clock -period " << mul.freq << " -name fast clk" << endl;
			tcl << "#set_multicycle_path -to c_reg[*] 3" << endl << endl;

			tcl << "compile_ultra" << endl;
			tcl << "optimize_registers" << endl; // this might not be optimal
		}
		
		tcl.close();
	}

}

void readResults() {
	for (const auto& mul : muls) { 
	
		string base = ""; 
		if (mul.name == "sbm_digitzed"){
			base = "../synth/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + "." + "dig" + to_string(mul.digit_size) + ".pip" + to_string(mul.pipeline);
		}
		else{
			base = "../synth/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + ".pip" + to_string(mul.pipeline);
		}
	
		string filename = base + ".area.rpt";
		ifstream arearpt (filename.c_str());
		filename = base + ".power.rpt";
		ifstream powerrpt (filename.c_str());
		filename = base + ".timing.rpt";
		ifstream timingrpt (filename.c_str());

		string tmp;

		int cells = -1;
		double area = -1.0;
		double leakage = -1.0;
		double dynamic = -1.0;
		int datapath = -1;
		int slack = -1;

		int counter = 0;
		while (arearpt) {
			arearpt >> tmp; 
			if (tmp == mul.name) {
				counter++;
			}
			if (counter == 2) {
				arearpt >> cells; // number of cells
				arearpt >> area; // cell area
				break;
			}
		}

		counter = 0;
		while (powerrpt) {
			powerrpt >> tmp; 
			if (tmp == mul.name) {
				counter++;
			}
			if (counter == 2) {
				//powerrpt >> tmp; // discard module name
				powerrpt >> tmp; // discard number of cells
				powerrpt >> leakage; // leakage power 
				powerrpt >> dynamic; // dynamic power 
				break;
			}
		}

		while (timingrpt) {
			timingrpt >> tmp; 
			if (tmp == "Path:-") {
				timingrpt >> datapath;
				timingrpt >> tmp; // discards slack keyword
				timingrpt >> slack; // slack in picoseconds
				break;
			}
		}

		std::cout << "----------------------------------------------------------------------" << endl;
		if (mul.name == "sbm_digitized"){
			std::cout << "multiplier: " << mul.name << " " << mul.width1 << "x" << mul.width2 << " dig " << mul.digit_size << " pip " << mul.pipeline << endl;
		}
		else{
			std::cout << "multiplier: " << mul.name << " " << mul.width1 << "x" << mul.width2 << " pip " << mul.pipeline << endl;
		}
		std::cout << "cells: " << cells << " area: " << area << std::endl;
		std::cout << "leakage: " << leakage << " dynamic: " << dynamic << std::endl;
		std::cout << "datapath: " << datapath << " slack: " << slack << std::endl;
		arearpt.close();
		powerrpt.close();
		timingrpt.close();
	}
}

static inline uint32_t log2(const uint32_t x) {
  uint32_t y;
  asm ( "\tbsr %1, %0\n"
      : "=r"(y)
      : "r" (x)
  );
  return y;
}

