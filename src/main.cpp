#include <iostream> 
#include <fstream>
#include <string>
#include <vector>

#include <stdint.h>
#include <sys/stat.h> 
#include <sys/types.h> 
#include <time.h>

#include "tinyxml2.h"
#include "verilogfactory.h"

using namespace std;

// global configs
int cores;
string target;
string libfolder;
string lib;

// multiplier configs
struct st_mul {
	string name;
	int width1;
	int width2;
  int digit_size;
	double freq;
	int pipeline;
};

vector <st_mul> muls;

void readConfig();
void genLogs();
void genMultipliers();
void genScripts();
void readResults();
static inline uint32_t log2(const uint32_t x);

int main(int argc, char** argv) 
{ 
	readConfig();
	genLogs();
	genMultipliers();
	genScripts();
	readResults();
	return 0; 
}

void readConfig() {
	tinyxml2::XMLDocument doc;
	doc.LoadFile( "config.xml" );

	cout << "Starting the tool, reading config.xml" << endl; 

	// reads tool configuration related stuff
	tinyxml2::XMLElement *root, *child, *child2, *child3, *child4, *child5;
	root = doc.FirstChildElement( "CONFIG" );
	if (!root) {
		cout << "error reading XML CONFIG root" << endl;
		return;
	}

	child = root->FirstChildElement( "CORES" );
	cores = atoi(child->GetText());

	child = root->FirstChildElement( "TARGET" );
	target = child->GetText();
	child = root->FirstChildElement( "LIBFOLDER" );
	libfolder = child->GetText();
	child = root->FirstChildElement( "LIB" );
	lib = child->GetText();

	// reads multiplier specific stuff
	root = doc.FirstChildElement( "MUL" );

	while (root) {
		child= root->FirstChildElement( "NAME" ); // there can be only one
		if (!child) {
			cout << "error reading XML child NAME" << endl;
			return;
		}
		string temp = child->GetText();

		child = root->FirstChildElement( "WIDTH1" ); // there can be many
		child2 = root->FirstChildElement( "WIDTH2" ); // there can be many
  		child3 = root->FirstChildElement( "DIGIT_SIZE" ); // there can be many
		child4 = root->FirstChildElement( "CLOCK" ); // there can be many
		child5 = root->FirstChildElement( "PIPELINE" ); // there can be many
		if (!child) {
			cout << "error reading XML child WIDTH1" << endl;
			return;
		}
		if (!child2) {
			cout << "error reading XML child WIDTH2" << endl;
			return;
		}
		if (!child3) {
			cout << "error reading XML child DIGIT_SIZE" << endl;
			return;
		}
    		if (!child4) {
			cout << "error reading XML child CLOCK" << endl;
			return;
		}
		if (!child5) {
			cout << "error reading XML child PIPELINE" << endl;
			return;
		}

		while (child) {
			cout << "mul: " << temp << " width1: " << child->GetText() << " width2: " << child2->GetText() << " digit_size: " << child3->GetText() << " freq: " << child4->GetText() << " stages: " << child5->GetText() << endl;

			struct st_mul mul = {temp, atoi(child->GetText()), atoi(child2->GetText()), atoi(child3->GetText()), stod(child4->GetText()), atoi(child5->GetText())};
			muls.push_back(mul);
			child = child->NextSiblingElement("WIDTH1");
			child2 = child2->NextSiblingElement("WIDTH2");
			child3 = child3->NextSiblingElement("DIGIT_SIZE");
     			child4 = child4->NextSiblingElement("CLOCK");
			child5 = child5->NextSiblingElement("PIPELINE");
		}

		root = root->NextSiblingElement("MUL");
	}
}

void genLogs() {
	for (const auto& mul : muls) { // const because we don't operate on the elements, only read
		string filename = "../vlog/" + mul.name + "/" + mul.name + ".log";
		ofstream log (filename.c_str());

		string dirname = "../vlog/" + mul.name;
		mkdir(dirname.c_str(), 0777);
		dirname = "../synth/" + mul.name;
		mkdir(dirname.c_str(), 0777);

		time_t     now = time(0);
		struct tm  tstruct;
		char       buf[80];
		tstruct = *localtime(&now);
		strftime(buf, sizeof(buf), "%Y-%m-%d.%X", &tstruct);

		if (log.is_open()) {
			log << "generated by libgen on " << buf << endl;
			log.close();
		}

	}

}

void genMultipliers() {
	for (const auto& mul : muls) { // const because we don't operate on the elements, only read
		string filename = "../vlog/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + ".pip" + to_string(mul.pipeline) +".v";
		ofstream vlog (filename.c_str());

		cout << filename << endl;

		if (!vlog.is_open()) {
			cout << "problem opening file " << filename << endl;
			return;
		}

		vlog << "// TalTech large integer multiplier library" << endl;
		vlog << "// Multiplier type: " << mul.name << endl;
		vlog << "// Parameters: " << mul.width1 << " " << mul.width2 << " " << mul.pipeline << endl;
		vlog << "// Target tool: " << target << endl;

		VerilogFactory fact;
		fact.setName(mul.name);

		if (mul.name == "simple") {
			fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", mul.width1 + mul.width2);

			vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET1]) << endl;
			vlog << fact.getResetStatement();
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::ELSEBEGIN]) << endl;
			vlog << VerilogFactory::scoper(2, fact.getMulLogicSimple(mul.pipeline)) << endl;		
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}

		if (mul.name == "schoolbook") {
			fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", mul.width1 + mul.width2);
			fact.addVar("count", log2(mul.width1) + 1); // TODO: check this is really width1
			if (mul.pipeline > 1) {
				fact.addVar("skip", log2(mul.pipeline - 1) + 1);
			}

			vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
			vlog << fact.getInternalDefinition() << endl; // pipelined inputs are declared here
			vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET1]) << endl;
			vlog << fact.getResetStatement();
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::ELSEBEGIN]) << endl;
			vlog << fact.getMulLogicSchoolbook(mul.width1, mul.width2, mul.pipeline) << endl;		
			vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}

		if (mul.name == "two_way_karatsuba") {
      
   		fact.addIO("clk", "input");
		fact.addIO("rst", "input");
		fact.addIO("a", "input", mul.width1);
		fact.addIO("b", "input", mul.width2);
		fact.addIO("c", "output reg", mul.width1 + mul.width2);
			
      // To declare wires in the generated verilog file
      fact.addWire("a1", mul.width1/2); // include wire
      fact.addWire("b1", mul.width1/2); // include wire
      fact.addWire("c1", mul.width1/2); // include wire
      fact.addWire("d1", mul.width1/2); // include wire
      fact.addWire("sum_a1b1", (mul.width1/2)+1); // include wire
      fact.addWire("sum_c1d1", (mul.width1/2)+1); // include wire
            
      // To declare reg in the generated verilog file
      fact.addVar("counter_a1c1", mul.width1/2); // will check 2 bits of a1
      fact.addVar("counter_b1d1", mul.width1/2); // will check 2 bits of b1
      fact.addVar("counter_sum_a1b1_c1d1", (mul.width1/2)+2); //will check 3 bits
      fact.addVar("mul_a1c1", mul.width1); // register to store multiplication result of a1 and c1 and its width will be sum of widths of a1 and c1
      fact.addVar("mul_b1d1", mul.width1); 
      fact.addVar("mul_sum_a1b1_sum_c1d1", mul.width1 + 2); 
      
      //fact.getAssignonWire(); // first parameter towards left is the destination while another parameter towards right is the source to be copied 
             
      /*
			if (mul.pipeline > 1) {
				fact.addVar("skip", log2(mul.pipeline - 1) + 1);
			}
      */
      
      vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			//vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
      vlog << "// Wires declaration " << endl;
      vlog << fact.getInternalDefinitionWire() << endl;
	vlog << "// Registers declaration " << endl;
	vlog << fact.getInternalDefinition() << endl; // pipelined inputs are declared here
			
      // Initial assignments
      vlog << "// Initializations / initial assignments" << endl;
      vlog << "assign a1 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_2() << "];" << endl;
      vlog << "assign b1 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_2_minus_1() << ":0];" << endl;
      vlog << "assign c1 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_2() << "];" << endl;
      vlog << "assign d1 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_2_minus_1() << ":0];" << endl << endl;
      
      // Step_1
      vlog << "// Step-1 of 2-Way Karatsuba Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET1]) << endl;
			//vlog << fact.getResetStatement();
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::ELSEBEGIN]) << endl;
			vlog << fact.getMulLogic_2_Way_Karatsuba_Step_1(mul.width1, mul.width2, mul.pipeline) << endl;		
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2
      vlog << endl << "// Step-2 of 2-Way Karatsuba Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_2_Way_Karatsuba_Step_2(mul.width1, mul.width2, mul.pipeline) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      vlog << endl << "// Assignments to sum_a1b1 and sum_c1d1" << endl;
      vlog << "assign sum_a1b1 = a1 ^ b1;" << endl;
      vlog << "assign sum_c1d1 = c1 ^ d1;" << endl;

      // Step_3
      vlog << endl << "// Step-3 of 2-Way Karatsuba Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_2_Way_Karatsuba_Step_3(mul.width1, mul.width2, mul.pipeline) << endl;
      vlog << fact.snippet[VerilogFactory::END] << endl;
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}
		
if (mul.name == "three_way_toom_cook") {
      
   		fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", (mul.width1 + mul.width2));
			
      // To split the input operands into three equal sizes
      //vlog << "// Here, we split the input operands into three equal sizes" << endl;
      fact.addWire("a0", (mul.width1/3)); // include wire
      fact.addWire("a1", (mul.width1/3)+1); // include wire
      fact.addWire("a2", (mul.width1/3)+1); // include wire
      fact.addWire("b0", (mul.width1/3)); // include wire
      fact.addWire("b1", (mul.width1/3)+1); // include wire
      fact.addWire("b2", (mul.width1/3)+1); // include wire
            
      // Counters for each step of 3-Way TCM multiplier
      //vlog << "// Counters deceleration for each step of 3-Way TCM multiplier" << endl;
      fact.addVar("counter_d", (mul.width1/3)); // will check bits of d
      fact.addVar("counter_e1", (mul.width1/3)); // will check bits of e1
      fact.addVar("counter_e2", (mul.width1/3)); // will check bits of e2
      fact.addVar("counter_f1", (mul.width1/3)); // will check bits of f1
      fact.addVar("counter_f2", (mul.width1/3)); // will check bits of f2
      fact.addVar("counter_f3", (mul.width1/3)); // will check bits of f3
      fact.addVar("counter_g1", (mul.width1/3)); // will check bits of g1
      fact.addVar("counter_g2", (mul.width1/3)); // will check bits of g2
      fact.addVar("counter_h", (mul.width1/3)); // will check bits of h
      
      // To store intermediate multiplication results
      //vlog << "// To store intermediate multiplication results of 3-Way TCM multiplier" << endl;
      fact.addVar("d", mul.width1); 
      fact.addVar("e1_mul", mul.width1);
      fact.addVar("e2_mul", mul.width1);
      fact.addVar("e", mul.width1); // e = e1_mul + e2_mul
      fact.addVar("f1_mul", mul.width1);
      fact.addVar("f2_mul", mul.width1);
      fact.addVar("f3_mul", mul.width1);
      fact.addVar("f", mul.width1); // f = f1_mul + f2_mul + f3_mul
      fact.addVar("g1_mul", mul.width1);
      fact.addVar("g2_mul", mul.width1);
      fact.addVar("g", mul.width1); // g = g1_mul + g2_mul
      fact.addVar("h", mul.width1);
      fact.addVar("temp", (mul.width1 + mul.width2));
      
      //vlog << "assign a0 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_2() << "];" << endl;
    
      //fact.getAssignonWire(); // first parameter towards left is the destination while another parameter towards right is the source to be copied 
             
      
			//if (mul.pipeline > 1) {
				//fact.addVar("skip", log2(mul.pipeline - 1) + 1);
			//}
      
      
      vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			//vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
      vlog << "// Wires declaration " << endl;
      vlog << fact.getInternalDefinitionWire() << endl;
      vlog << "// Registers declaration " << endl;
			vlog << fact.getInternalDefinition() << endl; // pipelined inputs are declared here
      
      // Initial assignments to wires
      vlog << "// Initial assignments to wires" << endl;
      vlog << "assign a0 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_3_minus_1() << ":0];" << endl;
      vlog << "assign a1 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_2_over_3_minus_1() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_3() << "];" << endl;
      vlog << "assign a2 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1_for_3_way_TCM() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_2_over_3() << "];" << endl;
      vlog << "assign b0 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_3_minus_1() << ":0];" << endl;
      vlog << "assign b1 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_2_over_3_minus_1() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_3() << "];" << endl;
      vlog << "assign b2 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1_for_3_way_TCM() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_2_over_3() << "];" << endl;
      
      
      // Step_1
      vlog << endl << "// Step-1 of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET1]) << endl;
			//vlog << fact.getResetStatement();
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::ELSEBEGIN]) << endl;
			vlog << fact.getMulLogic_3_Way_TCM_Step_1(mul.width1, mul.width2, mul.pipeline); 		
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-1)
      vlog << endl << "// Step-2 (Part-1) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_2_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-2)
      vlog << endl << "// Step-2 (Part-2) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_2_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-3)
      vlog << endl << "// Step-2 (Part-3) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_2_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
            
      // Step_3 (Part-1)
      vlog << endl << "// Step-3 (Part-1) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_3_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-2)
      vlog << endl << "// Step-3 (Part-2) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_3_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-3)
      vlog << endl << "// Step-3 (Part-3) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_3_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-4)
      vlog << endl << "// Step-3 (Part-4) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_3_part_4(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_4 (Part-1)
      vlog << endl << "// Step-4 (Part-1) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_4_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-2)
      vlog << endl << "// Step-4 (Part-2) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_4_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-3)
      vlog << endl << "// Step-4 (Part-3) of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_4_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_5
      vlog << endl << "// Step-5 of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_5(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_6
      vlog << endl << "// Step-6 of 3-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_3_Way_TCM_Step_6(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}

if (mul.name == "four_way_toom_cook") {
      
   		fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", (mul.width1 + mul.width2));
			
      // To split the input operands into three equal sizes
      //vlog << "// Here, we split the input operands into three equal sizes" << endl;
      fact.addWire("a0", (mul.width1/4)); // include wire
      fact.addWire("a1", (mul.width1/4)); // include wire
      fact.addWire("a2", (mul.width1/4)); // include wire
      fact.addWire("a3", (mul.width1/4)); // include wire
      fact.addWire("b0", (mul.width1/4)); // include wire
      fact.addWire("b1", (mul.width1/4)); // include wire
      fact.addWire("b2", (mul.width1/4)); // include wire
      fact.addWire("b3", (mul.width1/4)); // include wire
            
      // Counters for each step of 3-Way TCM multiplier
      //vlog << "// Counters deceleration for each step of 3-Way TCM multiplier" << endl;
      fact.addVar("counter_d", (mul.width1/4)); // will check bits of d
      fact.addVar("counter_e1", (mul.width1/4)); // will check bits of e1
      fact.addVar("counter_e2", (mul.width1/4)); // will check bits of e2
      fact.addVar("counter_f1", (mul.width1/4)); // will check bits of f1
      fact.addVar("counter_f2", (mul.width1/4)); // will check bits of f2
      fact.addVar("counter_f3", (mul.width1/4)); // will check bits of f3
      fact.addVar("counter_g1", (mul.width1/4)); // will check bits of g1
      fact.addVar("counter_g2", (mul.width1/4)); // will check bits of g2
      fact.addVar("counter_g3", (mul.width1/4)); // will check bits of g3
      fact.addVar("counter_g4", (mul.width1/4)); // will check bits of g4
      fact.addVar("counter_h1", (mul.width1/4)); // will check bits of h1
      fact.addVar("counter_h2", (mul.width1/4)); // will check bits of h2
      fact.addVar("counter_h3", (mul.width1/4)); // will check bits of h3
      fact.addVar("counter_i1", (mul.width1/4)); // will check bits of i1
      fact.addVar("counter_i2", (mul.width1/4)); // will check bits of i2
      fact.addVar("counter_j", (mul.width1/4)); // will check bits of j
      
      // To store intermediate multiplication results
      //vlog << "// To store intermediate multiplication results of 3-Way TCM multiplier" << endl;
      fact.addVar("d", mul.width1); 
      fact.addVar("e1_mul", mul.width1);
      fact.addVar("e2_mul", mul.width1);
      fact.addVar("e", mul.width1); // e = e1_mul + e2_mul
      fact.addVar("f1_mul", mul.width1);
      fact.addVar("f2_mul", mul.width1);
      fact.addVar("f3_mul", mul.width1);
      fact.addVar("f", mul.width1); // f = f1_mul + f2_mul + f3_mul
      fact.addVar("g1_mul", mul.width1);
      fact.addVar("g2_mul", mul.width1);
      fact.addVar("g3_mul", mul.width1);
      fact.addVar("g4_mul", mul.width1);
      fact.addVar("g", mul.width1); // g = g1_mul + g2_mul + g3_mul + g4_mul
      fact.addVar("h1_mul", mul.width1);
      fact.addVar("h2_mul", mul.width1);
      fact.addVar("h3_mul", mul.width1);
      fact.addVar("h", mul.width1); // h = h1_mul + h2_mul + h3_mul
      fact.addVar("i1_mul", mul.width1);
      fact.addVar("i2_mul", mul.width1);
      fact.addVar("i", mul.width1); // i = i1_mul + i2_mul
      fact.addVar("j", mul.width1);
      fact.addVar("temp", (mul.width1 + mul.width2));
      
      //vlog << "assign a0 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_2() << "];" << endl;
    
      //fact.getAssignonWire(); // first parameter towards left is the destination while another parameter towards right is the source to be copied 
             
      
			//if (mul.pipeline > 1) {
				//fact.addVar("skip", log2(mul.pipeline - 1) + 1);
			//}
      
      
      vlog << fact.getModuleDefinition() << endl;
			vlog << fact.getIODefinition() << endl;
			//vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
      vlog << "// Wires declaration " << endl;
      vlog << fact.getInternalDefinitionWire() << endl;
      vlog << "// Registers declaration " << endl;
			vlog << fact.getInternalDefinition() << endl; // pipelined inputs are declared here
      
      // Initial assignments to wires
      vlog << "// Initial assignments to wires" << endl;
      vlog << "assign a0 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_4() << ":0];" << endl;
      vlog << "assign a1 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_2_over_4() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_4() << "];" << endl;
      vlog << "assign a2 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_3_over_4() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_2_over_4() << "];" << endl;
      vlog << "assign a3 = a[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1_for_4_way_TCM() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_3_over_4() << "];" << endl;
      
      vlog << "assign b0 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_over_4() << ":0];" << endl;
      vlog << "assign b1 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_2_over_4() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_over_4() << "];" << endl;
      vlog << "assign b2 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_times_3_over_4() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_2_over_4() << "];" << endl;
      vlog << "assign b3 = b[" << fact.getInternalDefinitionAssignSetMSB_as_m_minus_1_for_4_way_TCM() << ":" << fact.getInternalDefinitionAssignSetLSB_as_m_times_3_over_4() << "];" << endl;
      
      
      // Step_1
      vlog << endl << "// Step-1 of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::RESET1]) << endl;
			//vlog << fact.getResetStatement();
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::ELSEBEGIN]) << endl;
			vlog << fact.getMulLogic_4_Way_TCM_Step_1(mul.width1, mul.width2, mul.pipeline); 		
			//vlog << VerilogFactory::scoper(1, fact.snippet[VerilogFactory::END]) << endl;
			vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-1)
      vlog << endl << "// Step-2 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_2_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-2)
      vlog << endl << "// Step-2 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_2_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_2 (Part-3)
      vlog << endl << "// Step-2 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_2_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
            
      // Step_3 (Part-1)
      vlog << endl << "// Step-3 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_3_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-2)
      vlog << endl << "// Step-3 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_3_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-3)
      vlog << endl << "// Step-3 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_3_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_3 (Part-4)
      vlog << endl << "// Step-3 (Part-4) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_3_part_4(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_4 (Part-1)
      vlog << endl << "// Step-4 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-2)
      vlog << endl << "// Step-4 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-3)
      vlog << endl << "// Step-4 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl; 
      
      // Step_4 (Part-4)
      vlog << endl << "// Step-4 (Part-4) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_4(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_4 (Part-5)
      vlog << endl << "// Step-4 (Part-5) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_4_part_5(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;     
      
      // Step_5 (Part-1)
      vlog << endl << "// Step-5 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_5_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_5 (Part-2)
      vlog << endl << "// Step-5 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_5_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_5 (Part-3)
      vlog << endl << "// Step-5 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_5_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_5 (Part-4)
      vlog << endl << "// Step-5 (Part-4) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_5_part_4(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_6 (Part-1)
      vlog << endl << "// Step-6 (Part-1) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_6_part_1(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_6 (Part-2)
      vlog << endl << "// Step-6 (Part-2) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_6_part_2(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_6 (Part-3)
      vlog << endl << "// Step-6 (Part-3) of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_6_part_3(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
      
      // Step_7
      vlog << endl << "// Step-7 of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_7(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // Step_8
      vlog << endl << "// Step-8 of 4-Way TCM Multiplier" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_4_Way_TCM_Step_8(mul.width1, mul.width2, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::END] << endl;      
			vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}
   
   if (mul.name == "sbm_digitized") {
      
      fact.addParameter("SIZEA", mul.width1);
      fact.addParameter("SIZEB", mul.width2);
      fact.addParameter("SIZEOF_DIGITS", mul.digit_size);
      fact.addParameter("DIGITS", (mul.width2/mul.digit_size)+1);
      
      fact.addIO("clk", "input");
			fact.addIO("rst", "input");
			fact.addIO("a", "input", mul.width1);
			fact.addIO("b", "input", mul.width2);
			fact.addIO("c", "output reg", (mul.width1 + mul.width2));
      
      fact.addVar("local_rst", 1);
      fact.addVar("digit_mul_start", 1);
      fact.addVar("digit_mul_start_next", 1);
      fact.addVar("short_b", mul.digit_size);
      fact.addVar("short_b_next", mul.digit_size);
      fact.addVar("counter_digits", mul.width2/mul.digit_size);
      fact.addVar("counter_digits_next", mul.width2/mul.digit_size);
      fact.addVar("state", 2); 
      fact.addVar("next_state", 2);
      fact.addVar("next_c", (mul.width1+mul.width2));
      fact.addVar("tmp", mul.width2);
      fact.addVar("upper_addr", (mul.width2/2)-1);
      fact.addVar("lower_addr", (mul.width2/2)-1);
      
      fact.addWire("digit_mul_done", 1);
      fact.addWire("short_c", (mul.width1 + mul.digit_size));
      
			//if (mul.pipeline > 1) {
				//fact.addVar("skip", log2(mul.pipeline - 1) + 1);
			//}
      
      vlog << fact.getModuleDefinition() << endl;      
      vlog << endl << "// Declaration of parameters" << endl;
      vlog << fact.getInternalDefinitionParameter() << endl;
      vlog << "// Declaration of module inputs and outputs" << endl;
			vlog << fact.getIODefinition() << endl;
      vlog << "// Set local parameters for FSM controller" << endl;
      vlog << "localparam ST_RUN = 0;" << endl;
      vlog << "localparam ST_WAIT = 1;" << endl;
      vlog << "localparam ST_OFFSET = 2;" << endl;
      vlog << "localparam ST_RST = 3;" << endl;
      vlog << endl << "// Registers declaration " << endl;
			vlog << fact.getInternalDefinition() << endl; 
			//vlog << fact.getTempVars(mul.pipeline) << endl; // pipelined inputs are declared here
      vlog << "// Wires declaration " << endl;
      vlog << fact.getInternalDefinitionWire() << endl;
      
      vlog << "// Multiplier Instance" << endl;
      vlog << "mult_unit #(" << mul.width2 << ", " << mul.digit_size << ") mult_unit (clk, rst, local_rst, a, short_b, digit_mul_start, short_c, digit_mul_done);" << endl;
      
      // FSM Controller -- Sequential Block
      vlog << endl << "// FSM-controller --< Sequential Part" << endl;
      vlog << fact.snippet[VerilogFactory::ALWAYS] << endl;
      vlog << fact.getMulLogic_sbm_digitized_FSM_sequential_logic(mul.width1, mul.width2, mul.digit_size, mul.pipeline);
			vlog << fact.snippet[VerilogFactory::END] << endl;
      
      // FSM Controller -- Combinational Block
      vlog << endl << "// FSM-controller --< Combinational Part" << endl;
      vlog << fact.getMulLogic_sbm_digitized_FSM_combinational_logic(mul.width1, mul.width2, mul.digit_size, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
      
      // multiplier inside the sbm_digitized
      vlog << endl << "// multiplier inside the sbm_digitized" << endl;
      vlog << "module mult_unit(clk, rst, local_rst, a, b, digit_mul_start, c, digit_mul_done);" << endl;
      
      vlog << endl << "// Declaration of parameters" << endl;
      vlog << "parameter SHORTA = 1;" << endl;
      vlog << "parameter SHORTB = 1;" << endl;
      
      vlog << endl << "// Declaration of module inputs and outputs" << endl;
      vlog << "input clk;" << endl;
			vlog << "input rst;" << endl;
      vlog << "input local_rst;" << endl;
      vlog << "input [" << (mul.width1-1) <<":0] a;" << endl;
      vlog << "input [" << (mul.digit_size-1) <<":0] b;" << endl;
      vlog << "input digit_mul_start;" << endl;
      vlog << "output reg [" << ((mul.width1 + mul.digit_size)-1) << ":0] c;" << endl;
      vlog << "output reg digit_mul_done;" << endl;
      
      vlog << endl << "// Registers declaration " << endl;
      vlog << "reg [11:0] count;" << endl;
 
      vlog << endl << fact.getMulLogic_multiplier_inside_sbm_digitized(mul.width1, mul.width2, mul.digit_size, mul.pipeline);
      vlog << fact.snippet[VerilogFactory::ENDMODULE] << endl;
		}
		vlog.close();
	}
}

void genScripts() {
	for (const auto& mul : muls) { 
		string filename = "../synth/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + ".pip" + to_string(mul.pipeline) + ".tcl";
		ofstream tcl (filename.c_str());

		if (!tcl.is_open()) {
			cout << "problem opening file " << filename << endl;
			return;
		}
	
		if (target == "genus") {
			tcl << "#created by TMlib" << endl;
			tcl << "set_db information_level 99" << endl;
			tcl << "set_db syn_global_effort express" << endl;
			tcl << "set_db syn_generic_effort express" << endl;
			tcl << "set_db syn_map_effort express" << endl;
			tcl << "set_db syn_opt_effort express" << endl;
			tcl << "set_db retime_verification_flow false" << endl;

			tcl << "set LIB {" << lib << "}" << endl;
			tcl << "set SOURCE_PATH {../../vlog/" << mul.name << "/}" << endl;
			tcl << "set FILE_LIST {" << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".v}" << endl;
			tcl << "set_db init_hdl_search_path \"$SOURCE_PATH\"" << endl;
			tcl << "set TOP MUL" << endl;

			tcl << "read_libs ${LIB}" << endl;
			tcl << "read_hdl \"$FILE_LIST\"" << endl;
			tcl << "time_info" << endl;
			tcl << "elaborate" << endl;
			tcl << "write_hdl -generic > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".generic.v" << endl;
			tcl << "time_info" << endl;
			tcl << "check_design -unresolved" << endl;
			tcl << "set_time_unit -nanoseconds" << endl;
			tcl << "set CLK_PORT_NAME clk" << endl;
			tcl << "create_clock -name \"fast\" -period " << mul.freq << " $CLK_PORT_NAME" << endl;
			tcl << "#double check this input delay line" << endl;
			tcl << "set_input_delay -clock fast 0.001 [all_inputs]" << endl;

			tcl << "set_dont_use SDF*" << endl;
			tcl << "set_dont_use SED*" << endl;
			tcl << "set_dont_use DEL*" << endl;
			tcl << "set_dont_use CK*" << endl;
			tcl << "set_dont_use LH*" << endl;
			tcl << "set_dont_use LN*" << endl;
			tcl << "set_dont_use *DCAP*" << endl;

			if (mul.pipeline > 1) {
				tcl << "retime -prepare -effort low" << endl;
				tcl << "time_info" << endl;
				tcl << "retime -min_delay" << endl;
				tcl << "time_info" << endl;
			}
			else {
				tcl << "syn_generic" << endl;
				tcl << "time_info" << endl;
				tcl << "syn_map" << endl;
				tcl << "time_info" << endl;
			}
			
			tcl << "syn_opt" << endl;
			tcl << "time_info" << endl;
	
			tcl << "write_hdl > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".mapped.v" << endl;
			tcl << "report_area > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".area.rpt" << endl;
			tcl << "report_power > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".power.rpt" << endl;
			tcl << "report_timing > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".timing.rpt" << endl;
			tcl << "report_gates > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".gates.rpt" << endl;
			tcl << "report_runtime > " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".runtime.rpt" << endl;
		}
		else if (target == "dc") {
			tcl << "#created by TMlib" << endl;
			tcl << "set search_path [list . \\" << endl;
			tcl << "[format \"%s%s\" SynopsysInstall /libraries/syn] \\" << endl;
			tcl << "[format \"%s%s\" SynopsysInstall /dw/sim_ver] \\" << endl;
			tcl << libfolder << " \\" << endl;
			tcl << "../../vlog/" << mul.name << "/]" << endl << endl;
	
			tcl << "set_host_options -max_cores " << cores << endl << endl;

			tcl << "set target_library [list " << lib << "]" << endl;
			tcl << "set link_library [concat [concat \"*\" $target_library] $synthetic_library]" << endl;
			tcl << "set fileFormat verilog" << endl;
			tcl << "set my_files [list " << mul.name << "." << mul.width1 << "x" << mul.width2 << ".pip" << mul.pipeline << ".v]" << endl << endl;

			tcl << "analyze -format $fileFormat -lib WORK $my_files" << endl;
			tcl << "elaborate " << mul.name << endl;
			tcl << "link" << endl;
			tcl << "uniquify" << endl << endl;

			tcl << "create_clock -period " << mul.freq << " -name fast clk" << endl;
			tcl << "#set_multicycle_path -to c_reg[*] 3" << endl << endl;

			tcl << "compile_ultra" << endl;
			tcl << "optimize_registers" << endl; // this might not be optimal
		}
		
		tcl.close();
	}

}

void readResults() {
	for (const auto& mul : muls) { 
		string base = "../synth/" + mul.name + "/" + mul.name + "." + to_string(mul.width1) + "x" + to_string(mul.width2) + ".pip" + to_string(mul.pipeline);
	
		string filename = base + ".area.rpt";
		ifstream arearpt (filename.c_str());
		filename = base + ".power.rpt";
		ifstream powerrpt (filename.c_str());
		filename = base + ".timing.rpt";
		ifstream timingrpt (filename.c_str());

		string tmp;

		int cells = -1;
		double area = -1.0;
		double leakage = -1.0;
		double dynamic = -1.0;
		int datapath = -1;
		int slack = -1;

		int counter = 0;
		while (arearpt) {
			arearpt >> tmp; 
			if (tmp == mul.name) {
				counter++;
			}
			if (counter == 2) {
				arearpt >> cells; // number of cells
				arearpt >> area; // cell area
				break;
			}
		}

		counter = 0;
		while (powerrpt) {
			powerrpt >> tmp; 
			if (tmp == mul.name) {
				counter++;
			}
			if (counter == 2) {
				//powerrpt >> tmp; // discard module name
				powerrpt >> tmp; // discard number of cells
				powerrpt >> leakage; // leakage power 
				powerrpt >> dynamic; // dynamic power 
				break;
			}
		}

		while (timingrpt) {
			timingrpt >> tmp; 
			if (tmp == "Path:-") {
				timingrpt >> datapath;
				timingrpt >> tmp; // discards slack keyword
				timingrpt >> slack; // slack in picoseconds
				break;
			}
		}

		std::cout << "----------------------------------------------------------------------" << endl;
		std::cout << "multiplier: " << mul.name << mul.width1 << "x" << mul.width2 << " pip " << mul.pipeline << endl;
		std::cout << "cells: " << cells << " area: " << area << std::endl;
		std::cout << "leakage: " << leakage << " dynamic: " << dynamic << std::endl;
		std::cout << "datapath: " << datapath << " slack: " << slack << std::endl;
		arearpt.close();
		powerrpt.close();
		timingrpt.close();
	}
}

static inline uint32_t log2(const uint32_t x) {
  uint32_t y;
  asm ( "\tbsr %1, %0\n"
      : "=r"(y)
      : "r" (x)
  );
  return y;
}

